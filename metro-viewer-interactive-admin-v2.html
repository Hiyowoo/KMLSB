<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>지하철 + 행정경계(시/군/구) 인터랙티브</title>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <style>
    html, body { height: 100%; margin: 0; }
    #map { height: 100%; }
    .toolbar{
      position:absolute; top:10px; left:10px;
      background:#fff; padding:10px; border-radius:8px;
      box-shadow:0 2px 8px rgba(0,0,0,0.15); z-index:1000; font-size:14px;
      display:inline-block; min-width:420px;
    }
    .row{ display:flex; align-items:center; gap:12px; }
    .row-top{ flex-wrap:wrap; }
    .row-lines{ margin-top:8px; }
    .line-select-label{ display:flex; align-items:flex-start; gap:8px; }
    #lineSelect{ width:300px; max-width:36vw; }
    .legend {
      position: absolute; bottom: 10px; left: 10px;
      background: rgba(255,255,255,0.95);
      padding: 8px 10px; border-radius: 6px;
      box-shadow:0 2px 6px rgba(0,0,0,0.15);
      z-index: 1000; font-size: 12px; max-width: 520px; line-height: 1.4;
    }
    .station-label {
      background: transparent; padding: 0; border: none;
      font-weight: bold; font-size: 13px; line-height: 1.2;
      white-space: nowrap; box-shadow: none; transform: translateY(-10px);
      pointer-events: none;
    }
    .admin-label{ 
      background: rgba(255,255,255,0.85); padding: 2px 4px; border-radius: 4px;
      font-size: 12px; border: 1px solid rgba(0,0,0,0.15); 
      white-space: nowrap;
    }
  </style>
</head>
<body>
  <div id="map"></div>

  <div class="toolbar">
    <div class="row row-top">
      <label><input type="checkbox" id="toggleStations" checked> 역 마커</label>
      <label><input type="checkbox" id="toggleLabels"> 역 이름 라벨</label>
      <button id="fitBtn">보기 영역 맞추기</button>
      <label><input type="checkbox" id="toggleSiGun"> 시/군</label>
      <label><input type="checkbox" id="toggleSiGunGu"> 시/군/구</label>
      <label><input type="checkbox" id="toggleAdminLabels"> 행정 라벨</label>
    </div>
    <div class="row row-lines">
      <label class="line-select-label">
        호선:
        <select id="lineSelect" multiple size="10"></select>
      </label>
    </div>
  </div>

  <div class="legend">
    <div><b>사용법</b></div>
    <div>• <em>시/군</em> 또는 <em>시/군/구</em> 체크로 경계 표시, 클릭하면 하이라이트</div>
    <div>• <em>행정 라벨</em> 체크 시, 확대(≥11)에서 이름 라벨 표시</div>
    <div>• 아래 줄: <em>호선</em> 다중 선택(Ctrl/Shift)</div>
  </div>

  <script>
    const map = L.map('map', { preferCanvas:true }).setView([37.5665, 126.9780], 11);
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      attribution: '&copy; OpenStreetMap contributors'
    }).addTo(map);

    const lineLayer = L.layerGroup().addTo(map);
    const stationMarkerLayer = L.layerGroup().addTo(map);
    const stationLabelLayer = L.layerGroup().addTo(map);

    // Admin
    let siGunLayer = null;    // L.GeoJSON
    let siGunGuLayer = null;  // L.GeoJSON
    const adminLabelLayer = L.layerGroup().addTo(map);
    let activeAdminLayer = null; // currently selected polygon layer

    // UI elements
    const lineSelect = document.getElementById('lineSelect');
    const toggleStations = document.getElementById('toggleStations');
    const toggleLabels = document.getElementById('toggleLabels');
    const fitBtn = document.getElementById('fitBtn');
    const toggleSiGun = document.getElementById('toggleSiGun');
    const toggleSiGunGu = document.getElementById('toggleSiGunGu');
    const toggleAdminLabels = document.getElementById('toggleAdminLabels');

    let lineData = null;
    let stationData = null;

    Promise.all([
      fetch('./data-metro-line-1.0.0.json').then(r => r.json()),
      fetch('./data-metro-station-1.0.0.json').then(r => r.json())
    ]).then(([lineJson, stationJson]) => {
      lineData = lineJson.DATA || [];
      stationData = stationJson.DATA || [];

      // 호선 목록
      const lines = Array.from(new Set(lineData.map(d => d.line))).sort();
      const optAll = document.createElement('option');
      optAll.value = '__ALL__'; optAll.textContent = '전체';
      lineSelect.appendChild(optAll);
      for (const ln of lines) {
        const opt = document.createElement('option');
        opt.value = ln; opt.textContent = ln;
        lineSelect.appendChild(opt);
      }
      Array.from(lineSelect.options).forEach(o => o.selected = (o.value === '__ALL__'));

      render();

      lineSelect.addEventListener('change', onLineSelectChange);
      toggleStations.addEventListener('change', updateToggles);
      toggleLabels.addEventListener('change', updateToggles);
      fitBtn.addEventListener('click', fitToVisible);
      map.on('zoomend', () => { updateLabelVisibility(); updateAdminLabels(); });

      // Admin toggles
      toggleSiGun.addEventListener('change', onToggleAdmin);
      toggleSiGunGu.addEventListener('change', onToggleAdmin);
      toggleAdminLabels.addEventListener('change', updateAdminLabels);
    }).catch(err => {
      console.error('데이터 로드 오류:', err);
      alert('JSON 파일을 불러오는 데 실패했습니다. 파일 경로를 확인하세요.');
    });

    function onLineSelectChange() {
      const values = getSelectedLines();
      if (values.includes('__ALL__') && values.length > 1) {
        Array.from(lineSelect.options).forEach(o => o.selected = (o.value === '__ALL__'));
      } else if (!values.length) {
        Array.from(lineSelect.options).forEach(o => o.selected = (o.value === '__ALL__'));
      }
      render();
    }

    function getSelectedLines() {
      return Array.from(lineSelect.selectedOptions).map(o => o.value);
    }

    function getLineColorMap() {
      const m = {};
      (lineData || []).forEach(d => { if (!m[d.line] && d.color) m[d.line] = d.color; });
      return m;
    }

    function render() {
      lineLayer.clearLayers();
      stationMarkerLayer.clearLayers();
      stationLabelLayer.clearLayers();

      const selectedValues = getSelectedLines();
      const colorMap = getLineColorMap();
      const bounds = [];

      const dashedLines = new Set(['동탄인덕원선']);
      const dashedPairs = new Set([
        'GTXA|서울|삼성','GTXA|삼성|서울','GTXA|삼성|수서','GTXA|수서|삼성'
      ]);

      (lineData || []).forEach(lineObj => {
        if (!selectedValues.includes('__ALL__') && !selectedValues.includes(lineObj.line)) return;
        const color = lineObj.color || '#008000';
        (lineObj.node || []).forEach(edge => {
          const via = edge.via || [];
          if (via.length >= 2) {
            const latlngs = via.map(([lat, lng]) => [lat, lng]);
            const fromName = edge.station && edge.station[0] ? edge.station[0].name : '';
            const toName   = edge.station && edge.station[1] ? edge.station[1].name : '';
            const isDashed = dashedLines.has(lineObj.line) || dashedPairs.has(`${lineObj.line}|${fromName}|${toName}`);
            const poly = L.polyline(latlngs, { color, weight: 4, opacity: 0.95, dashArray: isDashed ? '8 8' : null });
            poly.addTo(lineLayer);
            latlngs.forEach(ll => bounds.push(ll));
          }
        });
      });

      (stationData || []).forEach(st => {
        if (!selectedValues.includes('__ALL__') && !selectedValues.includes(st.line)) return;
        if (typeof st.lat !== 'number' || typeof st.lng !== 'number') return;
        const color = colorMap[st.line] || '#111';

        const marker = L.circleMarker([st.lat, st.lng], {
          radius: 4, weight: 1, color: '#222', fillColor: color, fillOpacity: 0.9
        }).bindTooltip(`${st.name} (${st.line})`, {direction:'top'});
        marker.addTo(stationMarkerLayer);

        const labelIcon = L.divIcon({ className: 'station-label', html: st.name, iconAnchor: [0, 0] });
        const label = L.marker([st.lat, st.lng], { icon: labelIcon, interactive: false });
        label.addTo(stationLabelLayer);

        bounds.push([st.lat, st.lng]);
      });

      updateToggles();
      if (bounds.length) map.fitBounds(bounds, { padding: [24,24] });
    }

    function updateToggles() {
      if (toggleStations.checked) { if (!map.hasLayer(stationMarkerLayer)) map.addLayer(stationMarkerLayer); }
      else { if (map.hasLayer(stationMarkerLayer)) map.removeLayer(stationMarkerLayer); }

      if (toggleLabels.checked) { if (!map.hasLayer(stationLabelLayer)) map.addLayer(stationLabelLayer); }
      else { if (map.hasLayer(stationLabelLayer)) map.removeLayer(stationLabelLayer); }

      updateLabelVisibility();
    }

    function updateLabelVisibility() {
      const showLabels = toggleLabels.checked && map.getZoom() >= 12;
      stationLabelLayer.eachLayer(layer => {
        const el = layer.getElement && layer.getElement();
        if (el) el.style.display = showLabels ? '' : 'none';
      });
    }

    function fitToVisible() {
      const b = L.latLngBounds([]);
      lineLayer.eachLayer(layer => { if (layer.getBounds) b.extend(layer.getBounds()); });
      stationMarkerLayer.eachLayer(layer => { if (layer.getLatLng) b.extend(layer.getLatLng()); });
      stationLabelLayer.eachLayer(layer => { if (layer.getLatLng) b.extend(layer.getLatLng()); });
      if (siGunLayer && map.hasLayer(siGunLayer)) b.extend(siGunLayer.getBounds());
      if (siGunGuLayer && map.hasLayer(siGunGuLayer)) b.extend(siGunGuLayer.getBounds());
      if (b.isValid()) map.fitBounds(b, { padding: [24,24] });
    }

    // ---------------- Admin boundaries (interactive) ----------------
    const URL_SIGUN = './jido_line_sigunonly.geojson';
    const URL_SIGUNGU = './jido_line_sigungu.geojson';

    const styleDefault = { color:'#000', weight:1.5, fillOpacity:0, opacity:1 };
    const styleHover   = { color:'#000', weight:3,   fillOpacity:0, opacity:1 };
    const styleActive  = { color:'#1971c2', weight:3, fillOpacity:0, opacity:1 };

    
    function getAdminName(f){
      const p = (f && f.properties) ? f.properties : {};
      // 1) common keys (case-insensitive)
      const keys = ["NAME_OUT","name","SIG_KOR_NM","SIG_NM","ADM_NM","A2","SGG_NM","SIG_NAME","sig_kor_nm","adm_nm"];
      for (const k of keys){
        for (const kk of Object.keys(p)){
          if (kk.toLowerCase() === k.toLowerCase()){
            const v = String(p[kk] ?? "").trim();
            if (v) return v;
          }
        }
      }
      // 2) heuristic: pick any string ending with '시'/'군'/'구'
      for (const [k,v] of Object.entries(p)){
        if (typeof v === 'string' && /[가-힣](시|군|구)$/.test(v.trim())) return v.trim();
      }
      // 3) last resort: first non-empty string
      for (const [k,v] of Object.entries(p)){
        if (typeof v === 'string' && v.trim().length >= 2) return v.trim();
      }
      return "";
    }


    function layerHandlers(layer, feature){
      layer.on({
        mouseover: (e) => {
          if (activeAdminLayer !== layer) layer.setStyle(styleHover);
        },
        mouseout: (e) => {
          if (activeAdminLayer !== layer) layer.setStyle(styleDefault);
        },
        click: (e) => {
          // clear previous
          if (activeAdminLayer && activeAdminLayer !== layer) activeAdminLayer.setStyle(styleDefault);
          activeAdminLayer = layer;
          layer.setStyle(styleActive);
          layer.bringToFront();
        }
      });
      const nm = getAdminName(feature);
      if (nm) layer.bindTooltip(nm, {sticky:true});
    }

    async function ensureSiGun(){
      if (siGunLayer) return;
      const res = await fetch(URL_SIGUN);
      const data = await res.json();
      siGunLayer = L.geoJSON(data, {
        style: styleDefault,
        onEachFeature: (f, l) => layerHandlers(l, f)
      });
    }
    async function ensureSiGunGu(){
      if (siGunGuLayer) return;
      const res = await fetch(URL_SIGUNGU);
      const data = await res.json();
      siGunGuLayer = L.geoJSON(data, {
        style: { ...styleDefault, weight: 1 },
        onEachFeature: (f, l) => layerHandlers(l, f)
      });
    }

    async function onToggleAdmin(){
      if (toggleSiGun.checked){
        await ensureSiGun(); if (!map.hasLayer(siGunLayer)) map.addLayer(siGunLayer);
      } else if (siGunLayer && map.hasLayer(siGunLayer)) { map.removeLayer(siGunLayer); }
      if (toggleSiGunGu.checked){
        await ensureSiGunGu(); if (!map.hasLayer(siGunGuLayer)) map.addLayer(siGunGuLayer);
      } else if (siGunGuLayer && map.hasLayer(siGunGuLayer)) { map.removeLayer(siGunGuLayer); }
      updateAdminLabels();
    }

    function updateAdminLabels(){
      adminLabelLayer.clearLayers();
      if (!toggleAdminLabels.checked) return;
      if (map.getZoom() < 10) return;

      function addLabelsFor(layer){
        if (!layer || !map.hasLayer(layer)) return;
        layer.eachLayer(poly => {
          if (!poly.getBounds) return;
          const center = poly.getBounds().getCenter();
          const nm = (poly.feature && getAdminName(poly.feature)) || '';
          if (!nm) return;
          const icon = L.divIcon({ className:'admin-label', html: nm });
          L.marker(center, { icon, interactive:false }).addTo(adminLabelLayer);
        });
      }
      addLabelsFor(siGunLayer);
      addLabelsFor(siGunGuLayer);
    }
  </script>
</body>
</html>
