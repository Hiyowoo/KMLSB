<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>미래 지하철 + 행정경계 (dashedRanges 최종)</title>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <style>
    html, body { height:100%; margin:0; }
    #map { height:100%; }
    .toolbar{
      position:absolute; top:10px; left:10px; z-index:1000;
      background:#fff; padding:10px; border-radius:8px;
      box-shadow:0 2px 8px rgba(0,0,0,.15); font-size:14px; min-width:460px;
    }
    .row{ display:flex; align-items:center; gap:12px; }
    .row-top{ flex-wrap:wrap; }
    .row-admin{ gap:12px; margin-top:8px; }
    .row-lines{ margin-top:8px; }
    .line-select-label{ display:flex; gap:8px; align-items:flex-start; }
    #lineSelect{ width:300px; max-width:36vw; }
    .legend{
      position:absolute; bottom:10px; left:10px; z-index:1000;
      background:rgba(255,255,255,.95); padding:8px 10px; border-radius:6px;
      box-shadow:0 2px 8px rgba(0,0,0,.15); font-size:12px; max-width:520px; line-height:1.4;
    }
    .station-label{
      background:transparent; padding:0; border:none; font-weight:bold; font-size:13px; line-height:1.2;
      white-space:nowrap; box-shadow:none; transform:translateY(-10px); pointer-events:none;
    }
    .admin-label{
      background:rgba(255,255,255,.85); padding:2px 4px; border-radius:4px; font-size:12px; border:1px solid rgba(0,0,0,.15);
      white-space:nowrap;
    }

        /* ── 역 팝업 배지용 ── */
    .popup-stn{min-width:180px}
    .popup-stn .title{font-weight:700;margin-bottom:6px;}
    .popup-stn .badges{display:flex;flex-wrap:wrap;gap:4px}
    .popup-stn .badge{padding:2px 6px;border-radius:10px;font-size:12px;color:#fff;white-space:nowrap}


  </style>
</head>
<body>
  <div id="map"></div>

  <div class="toolbar">
    <div class="row row-top">
      <label><input type="checkbox" id="toggleStations" checked> 역 마커</label>
      <label><input type="checkbox" id="toggleLabels"> 역 이름 라벨</label>
      <button id="fitBtn">보기 영역 맞추기</button>
    </div>
    <div class="row row-admin">
      <label><input type="checkbox" id="toggleSiGun"> 시/군</label>
      <label><input type="checkbox" id="toggleSiGunGu"> 시/군/구</label>
      <label><input type="checkbox" id="toggleAdminLabels"> 행정 라벨</label>
    </div>
    <div class="row row-lines">
      <label class="line-select-label">
        호선:
        <select id="lineSelect" multiple size="10"></select>
      </label>
    </div>
  </div>

  <div class="legend">
    <div><b>사용법</b></div>
    <div>• <em>시/군</em> 또는 <em>시/군/구</em> 체크로 경계 표시, 클릭하면 하이라이트</div>
    <div>• <em>행정 라벨</em> 체크 시, 확대(≥10)에서 이름 라벨 표시</div>
    <div>• 아래 줄: <em>호선</em> 다중 선택(Ctrl/Shift)</div>
  </div>

  <script>
    // ----- Utilities -----
    function getAdminName(f){
      const p = (f && f.properties) ? f.properties : {};
      const CITY_CODE_NAME = {"3110":"고양시","3104":"안양시","3102":"성남시","3101":"수원시","3119":"용인시","3109":"안산시","3401":"천안시","3304":"청주시","3501":"전주시","3701":"포항시","3811":"창원시"};
      const keys = ["NAME_OUT","name","SIG_KOR_NM","SIG_NM","ADM_NM","A2","SGG_NM","SIG_NAME","sig_kor_nm","adm_nm"];
      for (let k of keys){
        for (let kk in p){
          if (p.hasOwnProperty(kk) && kk.toLowerCase()===k.toLowerCase()){
            const v = (p[kk]!=null) ? String(p[kk]).trim() : "";
            if (!v) continue;
            if (/^\d{3,4}$/.test(v) && CITY_CODE_NAME[v]) return CITY_CODE_NAME[v];
            return v;
          }
        }
      }
      const grp = String(p.GROUP || "");
      const m = grp.match(/^C:(\d{3,4})$/);
      if (m && CITY_CODE_NAME[m[1]]) return CITY_CODE_NAME[m[1]];
      for (let k2 in p){ const v2 = p[k2]; if (typeof v2==='string' && /[가-힣](시|군|구)$/.test(v2.trim())) return v2.trim(); }
      for (let k3 in p){ const v3 = p[k3]; if (typeof v3==='string' && v3.trim().length>=2) return v3.trim(); }
      return "";
    }

    // ----- Map base -----
    const map = L.map('map', { preferCanvas:true }).setView([37.5665, 126.9780], 11);
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',{attribution:'&copy; OpenStreetMap contributors'}).addTo(map);

    const lineLayer = L.layerGroup().addTo(map);
    const stationMarkerLayer = L.layerGroup().addTo(map);
    const stationLabelLayer = L.layerGroup().addTo(map);
    let adminLabelLayer = L.layerGroup().addTo(map);

    // ----- UI refs -----
    const lineSelect = document.getElementById('lineSelect');
    const toggleStations = document.getElementById('toggleStations');
    const toggleLabels = document.getElementById('toggleLabels');
    const fitBtn = document.getElementById('fitBtn');
    const toggleSiGun = document.getElementById('toggleSiGun');
    const toggleSiGunGu = document.getElementById('toggleSiGunGu');
    const toggleAdminLabels = document.getElementById('toggleAdminLabels');

    // ----- Data holders -----
    let lineData = null;
    let stationData = null;
    let siGunLayer = null, siGunGuLayer = null, activeAdminLayer = null;

    // ----- Styles -----
    const styleDefault = { color:'#000', weight:1.5, fillOpacity:0, opacity:1 };
    const styleHover   = { color:'#000', weight:3,   fillOpacity:0, opacity:1 };
    const styleActive  = { color:'#1971c2', weight:3, fillOpacity:0, opacity:1 };

    function attachAdminHandlers(layer, feature){
      layer.on({
        mouseover(){ if (activeAdminLayer !== layer) layer.setStyle(styleHover); },
        mouseout(){  if (activeAdminLayer !== layer) layer.setStyle(styleDefault); },
        click(){
          if (activeAdminLayer && activeAdminLayer !== layer) activeAdminLayer.setStyle(styleDefault);
          activeAdminLayer = layer; layer.setStyle(styleActive); if (layer.bringToFront) layer.bringToFront();
        }
      });
      const nm = getAdminName(feature); if (nm) layer.bindTooltip(nm,{sticky:true});
    }

    function updateAdminLabels(){
      if (!adminLabelLayer) adminLabelLayer = L.layerGroup().addTo(map);
      adminLabelLayer.clearLayers();
      if (!toggleAdminLabels.checked) return;
      if (map.getZoom() < 10) return;
      function addLabelsFor(layer){
        if (!layer || !map.hasLayer(layer)) return;
        layer.eachLayer(function(poly){
          if (!poly.getBounds) return;
          const center = poly.getBounds().getCenter();
          const nm = (poly.feature && getAdminName(poly.feature)) || '';
          if (!nm) return;
          const icon = L.divIcon({ className:'admin-label', html: nm });
          L.marker(center, { icon, interactive:false }).addTo(adminLabelLayer);
        });
      }
      addLabelsFor(siGunLayer); addLabelsFor(siGunGuLayer);
    }

    // ----- Load & init -----
    (async function init(){
      try{
        const [lineJson, stationJson] = await Promise.all([
          fetch('./data-metro-line-2.0.0.json').then(r=>r.json()).catch(e=>{ console.warn('line JSON fetch fail',e); return {DATA:[]}; }),
          fetch('./data-metro-station-2.0.0.json').then(r=>r.json()).catch(e=>{ console.warn('station JSON fetch fail',e); return {DATA:[]}; })
        ]);
        lineData = lineJson.DATA || [];
        stationData = stationJson.DATA || [];

        const lines = Array.from(new Set(lineData.map(d=>d.line))).sort();
        const optAll = document.createElement('option'); optAll.value='__ALL__'; optAll.textContent='전체';
        lineSelect.appendChild(optAll);
        for (const ln of lines){ const o=document.createElement('option'); o.value=ln; o.textContent=ln; lineSelect.appendChild(o); }
        Array.from(lineSelect.options).forEach(o=>o.selected=(o.value==='__ALL__'));

        render();
        lineSelect.addEventListener('change', onLineSelectChange);
        toggleStations.addEventListener('change', updateToggles);
        toggleLabels.addEventListener('change', updateToggles);
        fitBtn.addEventListener('click', fitToVisible);
        map.on('zoomend', ()=>{ updateLabelVisibility(); updateAdminLabels(); });

        toggleSiGun.addEventListener('change', onToggleAdmin);
        toggleSiGunGu.addEventListener('change', onToggleAdmin);
        toggleAdminLabels.addEventListener('change', updateAdminLabels);
      }catch(e){
        console.error('초기화 오류:', e);
      }
    })();

    function onLineSelectChange(){
      const values = getSelectedLines();
      if (values.includes('__ALL__') && values.length>1){
        Array.from(lineSelect.options).forEach(o=>o.selected=(o.value==='__ALL__'));
      }else if(!values.length){
        Array.from(lineSelect.options).forEach(o=>o.selected=(o.value==='__ALL__'));
      }
      render();
    }
    function getSelectedLines(){ return Array.from(lineSelect.selectedOptions).map(o=>o.value); }
    function getLineColorMap(){ const m={}; (lineData||[]).forEach(d=>{ if(!m[d.line] && d.color) m[d.line]=d.color; }); return m; }

    // ====== 겹치는 역 통합 + 팝업에 모든 호선 표시 유틸 ======
    const ST_KEY_ROUND = 6; // 좌표 반올림(겹침 판정)
    function _stKey(lat,lng){ return `${(+lat).toFixed(ST_KEY_ROUND)},${(+lng).toFixed(ST_KEY_ROUND)}`; }
    function buildStationIndex(stationData, lineData){
      const idx = new Map();
      function add(st, lineName){
        if (!st || typeof st.lat !== 'number' || typeof st.lng !== 'number') return;
        const k = _stKey(st.lat, st.lng);
        if (!idx.has(k)){
          idx.set(k, {
            lat: +st.lat, lng: +st.lng,
            names: new Set(),
            lines: new Set(),
            station_nm_chn: st.station_nm_chn || null,
            station_nm_jpn: st.station_nm_jpn || null,
            station_nm_eng: st.station_nm_eng || null
          });
        }
        const o = idx.get(k);
        if (st.name) o.names.add(st.name);
        if (lineName) o.lines.add(lineName);
        if (st.station_nm_chn) o.station_nm_chn = st.station_nm_chn;
        if (st.station_nm_jpn) o.station_nm_jpn = st.station_nm_jpn;
        if (st.station_nm_eng) o.station_nm_eng = st.station_nm_eng;
      }
      (stationData||[]).forEach(st => add(st, st.line));
      (lineData||[]).forEach(lineObj=>{
        (lineObj.node||[]).forEach(edge=>{
          (edge.station||[]).forEach(s => add(s, lineObj.line));
        });
      });
      return Array.from(idx.values()).map(o => ({
        ...o,
        names: Array.from(o.names),
        lines: Array.from(o.lines)
      }));
    }
    function makeStationPopupHTML(o, colorMap){
      const title = o.names[0] || '(무명역)';
      const badges = o.lines
        .sort((a,b)=> (a||'').localeCompare(b||''))
        .map(l => `<span class="badge" style="background:${(colorMap&&colorMap[l])||'#666'}">${l}</span>`)
        .join('');
      return `<div class="popup-stn"><div class="title">${title}</div><div class="badges">${badges}</div></div>`;
    }

    // ====== 겹치는 VIA 자동 감지 + 평행(픽셀) 오프셋 렌더러 ======
    const OVERLAP_OFFSET_PX = 1;   // 라인들 사이 간격(px)
    const LINE_WEIGHT = 4;         // 라인 두께
    const VIA_ROUND = 6;           // via 좌표 반올림(겹침 판정)

    function _norm(v){ const m=Math.hypot(v.x,v.y)||1; return {x:v.x/m, y:v.y/m}; }
    function _add(a,b){ return {x:a.x+b.x, y:a.y+b.y}; }
    function _sub(a,b){ return {x:a.x-b.x, y:a.y-b.y}; }
    function _scale(v,s){ return {x:v.x*s, y:v.y*s}; }

    function offsetLatLngs(latlngs, offsetPx, map){
      if(!latlngs || latlngs.length<2) return latlngs;
      const pts = latlngs.map(ll => map.latLngToLayerPoint(L.latLng(ll[0], ll[1])));
      const segNormals = [];
      for(let i=0;i<pts.length-1;i++){
        const t = _norm(_sub(pts[i+1], pts[i]));
        const n = {x:-t.y, y:t.x};
        segNormals.push(n);
      }
      const vNormals = [];
      for(let i=0;i<pts.length;i++){
        if(i===0) vNormals.push(segNormals[0]);
        else if(i===pts.length-1) vNormals.push(segNormals[segNormals.length-1]);
        else vNormals.push(_norm(_add(segNormals[i-1], segNormals[i])));
      }
      const ptsOff = pts.map((p,i)=> _add(p, _scale(vNormals[i], offsetPx)));
      return ptsOff.map(p => {
        const ll = map.layerPointToLatLng(L.point(p.x, p.y));
        return [ll.lat, ll.lng];
      });
    }

    function keyOfVia(via){
      return JSON.stringify((via||[]).map(p => [ +(+p[0]).toFixed(VIA_ROUND), +(+p[1]).toFixed(VIA_ROUND) ]));
    }
    function offsetsFor(n, step=OVERLAP_OFFSET_PX){
      if(n<=1) return [0];
      const arr = [];
      if(n%2===1){
        const half=(n-1)/2;
        for(let i=-half;i<=half;i++) arr.push(i*step);
      }else{
        const half=n/2;
        for(let i=-half;i<0;i++) arr.push((i*2+1)*step/1);
        for(let i=0;i<half;i++)  arr.push((i*2+1)*step/1);
      }
      return arr;
    }

    // ===== 핵심: dashedRanges를 그래프 탐색으로 확장 =====
    function expandDashedRangesToPairs(lineData, dashedRanges, dashedPairs){
      const byLine = new Map();
      for (const lo of (lineData||[])){
        const edges = [];
        const adj = new Map();
        const verts = new Set();
        for (const e of (lo.node||[])){
          const a = e?.station?.[0]?.name; const b = e?.station?.[1]?.name;
          if (!a || !b) continue;
          edges.push({a,b});
          verts.add(a); verts.add(b);
          if(!adj.has(a)) adj.set(a, new Set());
          if(!adj.has(b)) adj.set(b, new Set());
          adj.get(a).add(b); adj.get(b).add(a);
        }
        byLine.set(lo.line, {edges, adj, verts});
      }
      function bfsPath(adj, s, t){
        if (!adj.has(s) || !adj.has(t)) return null;
        const q=[s]; const prev=new Map([[s,null]]); let head=0;
        while(head<q.length){
          const u=q[head++]; if (u===t) break;
          for (const v of (adj.get(u)||[])){
            if (!prev.has(v)){ prev.set(v,u); q.push(v); }
          }
        }
        if (!prev.has(t)) return null;
        const path=[]; let cur=t; while(cur!=null){ path.push(cur); cur=prev.get(cur); }
        path.reverse(); return path;
      }
      for (const rg of (dashedRanges||[])){
        const pack = byLine.get(rg.line);
        if (!pack){ console.warn('[dashedRanges] line not found:', rg.line); continue; }
        const {adj, verts} = pack;
        if (!verts.has(rg.start) || !verts.has(rg.end)){
          console.warn('[dashedRanges] station not found:', rg.line, rg.start, rg.end);
          continue;
        }
        const path = bfsPath(adj, rg.start, rg.end) || bfsPath(adj, rg.end, rg.start);
        if (!path || path.length<2){
          console.warn('[dashedRanges] path not found:', rg.line, rg.start, rg.end);
          continue;
        }
        for (let i=0;i<path.length-1;i++){
          const a=path[i], b=path[i+1];
          dashedPairs.add(`${rg.line}|${a}|${b}`);
          dashedPairs.add(`${rg.line}|${b}|${a}`);
        }
      }
    }

    function render(){
      lineLayer.clearLayers(); stationMarkerLayer.clearLayers(); stationLabelLayer.clearLayers();
      const selectedValues = getSelectedLines(); const colorMap=getLineColorMap(); const bounds=[];

      // 1) 라인 전체 점선
      const dashedLines = new Set(['동탄인덕원선','신안산선','위례선','동북선']);

      // 2) 간선(역-역) 점선
      const dashedPairs = new Set([
        'GTXA|서울|삼성','GTXA|삼성|서울','GTXA|삼성|수서','GTXA|수서|삼성',
        '4호선|인덕원|과천정보타운','4호선|과천정보타운|인덕원','4호선|과천정보타운|정부과천청사','4호선|정부과천청사|과천정보타운'
      ]);

      // 3) 구간(시작~끝) 점선 —> 그래프 탐색으로 dashedPairs에 자동 확장
      const dashedRanges = [
        { line:'7호선', start:'청라국제도시', end:'석남' },
        { line:'7호선', start:'장암',         end:'포천' },
        { line:'7호선', start:'덕정',         end:'옥정중앙' }
      ];
      expandDashedRangesToPairs(lineData, dashedRanges, dashedPairs);

      // ==== 라인 세그먼트 수집 (선택된 호선만) ====
      const segments = [];
      (lineData||[]).forEach(function(lineObj){
        if (!selectedValues.includes('__ALL__') && !selectedValues.includes(lineObj.line)) return;
        const color = lineObj.color || '#008000';
        (lineObj.node||[]).forEach(function(edge){
          const via = edge.via || [];
          if (via.length >= 2){
            const latlngs = via.map(function(xy){ return [xy[0], xy[1]]; });
            const fromName = edge.station && edge.station[0] ? edge.station[0].name : '';
            const toName   = edge.station && edge.station[1] ? edge.station[1].name : '';
            const dashed = dashedLines.has(lineObj.line) || dashedPairs.has(lineObj.line+'|'+fromName+'|'+toName);
            segments.push({ line: lineObj.line, color, latlngs, dashed, fromName, toName });
            latlngs.forEach(function(ll){ bounds.push(ll); });
          }
        });
      });

      // ==== 겹치는 VIA 자동 감지 → 평행(오프셋) 그리기 ====
      const buckets = new Map();
      segments.forEach(function(s){
        const k = keyOfVia(s.latlngs);
        if (!buckets.has(k)) buckets.set(k, []);
        buckets.get(k).push(s);
      });

      buckets.forEach(function(arr){
        if (arr.length === 1){
          const s = arr[0];
          L.polyline(s.latlngs, {
            color: s.color, weight: LINE_WEIGHT, opacity: 0.95,
            dashArray: s.dashed ? '8 8' : null
          }).addTo(lineLayer);
        } else {
          arr.sort(function(a,b){ return (a.line||'').localeCompare(b.line||''); });
          const offs = offsetsFor(arr.length, OVERLAP_OFFSET_PX);
          for (let i=0;i<arr.length;i++){
            const s = arr[i];
            const llOff = offsetLatLngs(s.latlngs, offs[i], map);
            L.polyline(llOff, {
              color: s.color, weight: LINE_WEIGHT, opacity: 0.95,
              dashArray: s.dashed ? '8 8' : null
            }).addTo(lineLayer);
          }
        }
      });
      
      // === 겹치는 역 통합 후, 팝업에 모든 호선 배지 표시 ===
      const stIndexArray = buildStationIndex(stationData, lineData);
      stIndexArray.forEach(function(o){
        if (!selectedValues.includes('__ALL__')){
          const hit = o.lines.some(function(l){ return selectedValues.includes(l); });
          if (!hit) return;
        }
        const chosenLines = selectedValues.includes('__ALL__') ? o.lines.slice() : o.lines.filter(l => selectedValues.includes(l));
        const primaryLine = (chosenLines[0] || o.lines[0]);
        const fillColor = colorMap[primaryLine] || '#111';
        const marker = L.circleMarker([o.lat, o.lng], {
          radius: 4, weight: 1, color: '#222',
          fillColor: fillColor, fillOpacity: 0.9
        }).addTo(stationMarkerLayer);
        marker.bindPopup(makeStationPopupHTML(o, colorMap));
        const labelName = (o.names[0] || '');
        if (labelName){
          const labelIcon = L.divIcon({ className:'station-label', html: labelName, iconAnchor:[0,0] });
          L.marker([o.lat, o.lng], { icon: labelIcon, interactive:false }).addTo(stationLabelLayer);
        }
        bounds.push([o.lat, o.lng]);
      });

      updateToggles();
      if (bounds.length) map.fitBounds(bounds,{padding:[24,24]});
    }

    function updateToggles(){
      if (toggleStations.checked){ if (!map.hasLayer(stationMarkerLayer)) map.addLayer(stationMarkerLayer); }
      else { if (map.hasLayer(stationMarkerLayer)) map.removeLayer(stationMarkerLayer); }
      if (toggleLabels.checked){ if (!map.hasLayer(stationLabelLayer)) map.addLayer(stationLabelLayer); }
      else { if (map.hasLayer(stationLabelLayer)) map.removeLayer(stationLabelLayer); }
      updateLabelVisibility();
    }

    function updateLabelVisibility(){
      const showLabels = toggleLabels.checked && map.getZoom() >= 12;
      stationLabelLayer.eachLayer(function(layer){
        const el = layer.getElement && layer.getElement();
        if (el) el.style.display = showLabels ? '' : 'none';
      });
    }

    function fitToVisible(){
      const b=L.latLngBounds([]);
      lineLayer.eachLayer(function(layer){ if (layer.getBounds) b.extend(layer.getBounds()); });
      stationMarkerLayer.eachLayer(function(layer){ if (layer.getLatLng) b.extend(layer.getLatLng()); });
      stationLabelLayer.eachLayer(function(layer){ if (layer.getLatLng) b.extend(layer.getLatLng()); });
      if (siGunLayer && map.hasLayer(siGunLayer) && siGunLayer.getBounds) b.extend(siGunLayer.getBounds());
      if (siGunGuLayer && map.hasLayer(siGunGuLayer) && siGunGuLayer.getBounds) b.extend(siGunGuLayer.getBounds());
      if (b.isValid()) map.fitBounds(b,{padding:[24,24]});
    }

    // ----- Admin boundaries toggle -----
    const URL_SIGUN   = './jido_line_sigunonly.geojson';
    const URL_SIGUNGU = './jido_line_sigungu.geojson';

    async function ensureSiGun(){
      if (siGunLayer) return;
      try{
        const res = await fetch(URL_SIGUN); const data = await res.json();
        siGunLayer = L.geoJSON(data, { style: styleDefault, onEachFeature:(f,l)=>attachAdminHandlers(l,f) });
      }catch(e){ console.error('시/군 GeoJSON 로드 오류', e); }
    }
    async function ensureSiGunGu(){
      if (siGunGuLayer) return;
      try{
        const res = await fetch(URL_SIGUNGU); const data = await res.json();
        siGunGuLayer = L.geoJSON(data, { style:{color:'#000',weight:1,fillOpacity:0,opacity:1}, onEachFeature:(f,l)=>attachAdminHandlers(l,f) });
      }catch(e){ console.error('시/군/구 GeoJSON 로드 오류', e); }
    }
    async function onToggleAdmin(){
      if (toggleSiGun.checked){ await ensureSiGun(); if (siGunLayer && !map.hasLayer(siGunLayer)) map.addLayer(siGunLayer); }
      else { if (siGunLayer && map.hasLayer(siGunLayer)) map.removeLayer(siGunLayer); }
      if (toggleSiGunGu.checked){ await ensureSiGunGu(); if (siGunGuLayer && !map.hasLayer(siGunGuLayer)) map.addLayer(siGunGuLayer); }
      else { if (siGunGuLayer && map.hasLayer(siGunGuLayer)) map.removeLayer(siGunGuLayer); }
      updateAdminLabels();
    }
  </script>
</body>
</html>
